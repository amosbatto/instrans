<?php
/************************************************************************
File: instrans.php
License: Latest version of GNU General Protection License (GPL) 
		which can be found at http://www.gnu.org 
Author: Amos B. Batto (amosbatto@yahoo.com, http://www.ciber-runa.net/ab)
Created: 22 Jun 2006; Last Revised: 30 Jun 2006
 
instrans.php inserts translations from one PO file into another PO file.
This is the command line version of this program.  If you want use this 
program in a web page, use instrans-form.php and instrans-form.html which 
calls this program.

For more information about this program and examples, see the accompanying 
readme-es.txt (Spanish), readme-en.txt (English), or readme-pt.txt 
(my bad Portuguese). 
If reading this code, set your tab size equal to 4 spaces.
*************************************************************************/

//When this script is saved as a UTF-8 text document and run on the command line,
//causes three characters of garbage (U+00B4 U+2557 U+2510) to appear on the screen 
//in MS-DOS using PHP 5.1.4 (cli) in Windows XP Home Edition, Service Pack 2 (version 5.1)
//In Ubuntu 5.10 (breezy badger) PHP 5.0.5 (cli) it causes two mid-line dots to appear
//on the screen. I will register it as a bug.

$startTime = microtime(true);

ini_set("auto_detect_line_endings", "On");
//set no max time for this program to run.
ini_set("max_execution_time", 0);

//Define Global Variables:
$sOrigPo = null;		//name de the original PO file o directory
//$rOrigPoDir = null;		//resource handle for sOrigPo if a directory
$sTransPo =	null;		//name of PO file or directory containing translations to be inserted in sOrigPo 
$rTransPoDir = null;	//resource handle for sTransPo if a directory
$sNewPo = null;			//new PO file or directory that will be written
$sNewPoDir = null;		//resource handle for rNewPoFile if a directory
$sTempDir = null;		//name of the temporary directory to be renamed to sNewPo when done processing
$rTempDir = null;		//resource handle for sTempDir
$sTempFile = null;		//name of temporary file being written, so won't overwrite sOrigPoFile until done processing it.
$rTempFile = null;		//resource handle for sTempFile
//Need a temporary directory because sNewPo can be the same as sOrigPo, so don't want
//to overwrite sOrigPo at the same time as you are reading from it.

$bLog = false;			//If true, then redirect screen messages to a log file
$rLogFile =	null;		//resource handle for log file
$sLogFile =	"instrans-log.txt";	//filename for rLogFile

//Set default values which can be changed by arguments passed by the user:
$bMsgstrIns = false;	//if true, then insert transalations from rTransPoFile in the msgstr
$bCommentIns = false;	//if true, then insert translations from rTransPoFile as comments
$bOverwrite = false;	//If true, then overwrite existing msgstr (or comments)
$bVerbose = false;		//If true, then display warnings and summary info at the end
$bQuiet = false;		//If true, then don't display any screen messages
$bRecursive = false;	//If true, then process the subdirectories as well.
$bSearch = false;		//If true, then search for  
$bNoStripVar = false;	//If true, then don't strip C/C++ variables and & (keyboard accelerators) 
						//from the translated frase when using the options --statusbar and 
						//--bilingual. Having these can cause errors in the program. 
						
//$bShowPath = false;	//Not implemented//If true, then show complete path of filenames in messages 						

//If bBilingualIns=true, then transation from rTransPoFile will be appended to msgstr so 
//both languages appear together: 
//	msgstr "ORIGINAL-STRING sBilingualSeparator APPENDED-STRING"
//	Example: msgstr "open * abrir" 
$bBilingualIns = false; 	
$sBilingualSeparator = ' * ';

$bStatusBarIns	= false;	//if true, then insert menu items in the status bar  
$sMenuSrch	= null;		//The strings to search for in the automatic comments in order 
$sStatusBarSrch = null;	//to find the menu and status bar PO objects 
$sLangComment = null;	//Language indentifier to be inserted with comments
$bDebug = false;		//pass the argument -d or --debug get debugging information
$bDir = false; 			//if true, then processing a whole directory of PO files


//Set global counter variables to 0
$totAmpersandStrips = 0; 
$totVarStrips = 0;
$totOrigPoFileLines = 0;
$totTransPoFileLines = 0;
$totNewPoFileLines = 0;
$totOrigPoObjs = 0;
$totTransPoObjs = 0;
$totNewPoObjs = 0;
$totOrigPoSyntaxErr = 0;
$totTransPoSyntaxErr = 0; 
$totNewPoSyntaxErr = 0;
$totFraseInserts = 0;//not implemented yet

$cntAmpersandStrips = 0; //make global because used outside processPoFile()
$cntVarStrips = 0;		//ditto

$sErr = ''; //global error message 
$aTransPo;	//array of PO objects pulled from the TRANSLATION-PO file by processPoFile()
$sOrigWDir = getcwd(); //store the original working directory, so can return to it later

//open files with the interface translations so instrans is multi-lingual
$sProgramPath = pathinfo(realpath($argv[0]), PATHINFO_DIRNAME); 
include($sProgramPath . '/mygettext.php'); 

if ($sInterfaceLang != DEF_SOURCE_LANG)
	include($sProgramPath . '/locale/' . $sInterfaceLang);
	
include($sProgramPath . '/help.php');

	
getArgs();	//get arguments passed by the user	
unset($sHelp); //$sHelp uses up a lot of memory and isn't needed anymore

if ($bLog)
{
	$rLogFile = fopen($sLogFile, 'wt');
	if ($rLogFile === false)
		shutdown(sprintf(__("Error: No puede abrir el archivo log \"%s\"."), 
			$sLogFile), 6);
}		

//getArgs checks that both sPoFile and sTransPoFile are the same thing, so I know that 
//sTransPo is also a directory if sPoFile is a directory 
if (!is_dir($sOrigPo))
	processPoFile($sOrigPo, $sTransPo, $sNewPo, $sNewPo);
else //if a directory
{
	$bDir = true;
	
	//Make a temporary directory to hold new PO files while processing.
	$sTempDir = getcwd() . ($bDOS ? '\\' : '/') . "instrans_" . $startTime;
	
	if (!mkdir($sTempDir))
		shutdown(sprintf(__("Error: No puede crear el directorio temporario \"%s\"."), 
			$sTempDir), 31);
	
	processDir($sOrigPo, $sTransPo, $sTempDir, $sNewPo);
	
	if (file_exists($sNewPo))
	{
		if ($bDOS)
			system('rmdir /s /q ' . $sNewPo, $iRet);
		else 	//if Linux/UNIX/OS X
			system('rm -r -d ' . $sNewPo, $iRet); 
			
		if ($iRet)
			shutdown(sprintf(__("Error: No puede sobre-escribir el directorio \"%s\"."),
				$sNewPo), 32);
	}
	
	if (!rename($sTempDir, $sNewPo))
		shutdown(sprintf(__("Error: No puede renombrar el directorio \"%s\"."), $sNewPo), 33);
}

if (!$bQuiet)
{
	$sOut = $bVerbose ? __("\nResumen de procesamiento total:\n") : "\n";
	$sOut .= sprintf(__(
		"%d líneas, %d objetos PO y %d errores de sintaxis leido de \"%s\"\n" . 
		"%d líneas, %d objetos PO y %d errores de sintaxis leido de \"%s\"\n" .
		"%d líneas y %d objetos PO escrito en \"%s\"\n"),
		$totOrigPoFileLines, $totOrigPoObjs, $totOrigPoSyntaxErr, $sOrigPo, 
		$totTransPoFileLines, $totTransPoObjs, $totTransPoSyntaxErr, $sTransPo,
		$totNewPoFileLines, $totNewPoObjs, $sNewPo);
		
	if (($bStatusBarIns || $bBilingualIns) && substr(phpversion(), 0, 3) >= 5.1)
		$sOut .= sprintf(__("%d signos \"&\" y %d variables quitado.\n"), 
			$totAmpersandStrips, $totVarStrips);
	
	if ($bVerbose)
		$sOut .= sprintf(__("Tiempo de procesamiento total: %f segundos.\n"), 
			microtime(true) - $startTime);
			
	output($sOut, true);	
}

return 0;
//end of program

//class holding PO object with all the formatting stripped off
class PoObj
{
	/*Each PO object has the following format:
	WHITE-SPACE
    # TRANSLATOR-COMMENTS
    #. AUTOMATIC-COMMENTS
    #: REFERENCE...
    #, FLAG...
    msgid UNTRANSLATED-STRING
    msgstr TRANSLATED-STRING */

	//all PO elements will be arrays, because they can be multiline:
	public $aTransCom; 
	public $aAutoCom;
	public $aRef;
	public $aFlag;
	public $aMsgid;
	public $aMsgstr;

	//Returns a string which contains the PO object with new lines (\n)
	//Adds blank line to the end to terminate the PO object.
	public function getStr()
	{
		$sPo = '';
		
		if(is_array($this->aTransCom))
			foreach ($this->aTransCom as $s)
				$sPo .= '#  ' . $s . "\n";		
		
		if(is_array($this->aAutoCom))
			foreach ($this->aAutoCom as $s)
				$sPo .= '#. ' . $s . "\n";
		
		if(is_array($this->aRef))
			foreach ($this->aRef as $s)
				$sPo .= '#: ' . $s . "\n";
		
		if(is_array($this->aFlag))
			foreach ($this->aFlag as $s)
				$sPo .= '#, ' . $s . "\n";
		
		if(is_array($this->aMsgid))
		{
			$sPo .= 'msgid ';
			foreach ($this->aMsgid as $s)
				$sPo .= '"' . $s . "\"\n";
		}

		if(is_array($this->aMsgstr))
		{
			$sPo .= 'msgstr ';
			foreach ($this->aMsgstr as $s)
				$sPo .= '"' . $s . "\"\n";
		}
		
		if ($sPo != '')	//add a blank line if not empty string
			$sPo .= "\n";

		return $sPo;	
	}

	//When reading a PO object from a file or an array, pass
	//one line at a time into function addLine() which strips
	//off padding and flags ("#" "#." "#:" "#," "msgid" 
	//"msgstr" and double quotes) and adds line to a PoObj object.
	//
	//If returns a negative number, then error in sLine:
	//-1: sLine is not a string, -2: no msgid defined for a quotation, 
	//-3: quote doesn"t end in double quotes, -4:some other problem.  
	//If returns 0, then blank line, so end of PO object. 
	//If returns positive number, then sLine was added to PO object.
	public function addLine($sLine)
	{
		global $sErr;
		if (!is_string($sLine))
			return -1;

		$sLine = trim($sLine);
			
		if ($sLine === '')
		{
			return 0;
		}
		elseif ($sLine[0] === '#')
		{
			if (strlen($sLine) <= 1)		//if a blank translator comment
				$this->aTransCom[] = '';
			elseif ($sLine[1] === '.')		//if automatic comment
				$this->aAutoCom[] = ltrim(substr($sLine, 2));
			elseif ($sLine[1] === ':')		//if reference	
				$this->aRef[] = ltrim(substr($sLine, 2));
			elseif ($sLine[1] === ',')		//if flag
				$this->aFlag[] = ltrim(substr($sLine, 2));
			else							//if a translator comment
				$this->aTransCom[] = ltrim(substr($sLine, 1));
			
			return 1;
		}
		elseif ($sLine[0] === '"')	//if another line of a msgid or msgstr
		{
			//if the msgid isn't defined yet, then syntax error
			if ($this->aMsgid === null)
			{
				$sErr = __("El msgid todavia no es definido.");
				return -2;
			}
			//if line doesn't terminate in double quotes, then syntax error
			elseif ($sLine[strlen($sLine) - 1] != '"') 
			{
				$sErr = __("Línea no termina en comillas.");
				return -3;
			}
			//if msgstr isn't set yet, then still continuing the msgid
			elseif ($this->aMsgstr === null)
			{
				$this->aMsgid[] = substr($sLine, 1, -1); //strip double quotes from ends
				return 2;
			}
			//else continuing the msgstr
			else
			{
				$this->aMsgstr[] = substr($sLine, 1, -1);
				return 3;
			}
		}			
		elseif (ereg("^msgid[ \t]+\".*\"$", $sLine))	//if a msgid
		{
			$this->aMsgid[] = substr(strstr($sLine, '"'), 1, -1);  
			return 2;
		}
		elseif (ereg("^msgstr[ \t]+\".*\"$", $sLine))	//if a msgstr
		{		
			$this->aMsgstr[] = substr(strstr($sLine, '"'), 1, -1);  
			return 3;
		}
			
		//if reached this point, then syntax error
		$sErr = __("Línea no tiene forma conocida.");
		return -4;	
	}
			

	//returns 0 if the msgids in the two po objects don"t match
	//returns 1 if only the msgids match
	//returns 2 if msgid and automatic comments match
	//returns 3 if msgid and reference match
	//returns 4 if msgid, reference, and automatic comments match
	public function match(PoObj $po)
	{
		if ($this->strMsgid() === $po->strMsgid())
		{
			if ($this->strRef() === $po->strRef())
			{
			  	if ($this->strAutoCom() === $po->strAutoCom())
					return 4;
				else
					return 3;
			}
			elseif ($this->strAutoCom() === $po->strAutoCom())
			{
			  	if ($this->strRef() === $po->strRef())
					return 4;
				else
					return 2;
			}	
			return 1;
		}	
		return 0;
	}

	public function clear()
	{
		$this->aTransCom = $this->aAutoCom = $this->aRef = $this->aFlag =
			$this->aMsgid = $this->aMsgstr = null;
		return;
	}
	
	public function cntLines()
	{
		return count($this->aTransCom) + count($this->aAutoCom) + count($this->aRef) + 
			count($this->aFlag) + count($this->aMsgid) + count($this->aMsgstr);
	}
	
	public function strAutoCom()
	{
		return (is_array($this->aAutoCom) ? implode('', $this->aAutoCom) : null);
	}
	
	public function strRef()
	{
		return (is_array($this->aRef) ? implode('', $this->aRef) : null);
	}
	
	public function strFlag()
	{
		return is_array($this->aFlag) ? implode('', $this->aFlag) : null;
	}
	
	//returns the msgid as a string
	public function strMsgid()
	{
		return is_array($this->aMsgid) ? implode('', $this->aMsgid) : null;
	}
	
	public function strMsgstr()
	{
		return is_array($this->aMsgstr) ? implode('', $this->aMsgstr) : null;
	}
	
	//Function stripDangerous() strips out any c-style variables from its aMsgstr 
	//and removes ampersands ("&" or "&amp;") which are followed immediately by 
	//alphanumeric characters.  Returns a warning message if variables were stripped.
	//Otherwise returns false.
	public function stripDangerous()
	{
		global $cntAmpersandStrips, $cntVarStrips;
		$cnt = 0;
		
		if (!is_array($this->aMsgstr))
			return false;
		
		$s = implode('', $this->aMsgstr);
		
		if (substr(phpversion(), 0, 3) >= 5.1) //if PHP version 5.1.0 or later
		{
			//because found at array position 0 and false are confusable, need to use ===
			if (strpos($s, '&') !== false)
			{	
				if (strpos($s, '&amp;') === false)
					$this->aMsgstr = preg_replace('/&(\w)/', '$1', $this->aMsgstr, -1, $cnt);
				else
					$this->aMsgstr = preg_replace('/&amp;(\w)/', '$1', $this->aMsgstr, -1, $cnt);
			
				$cntAmpersandStrips += $cnt;
			}
			
			if (is_array($this->aFlag) && 
				!(strpos(implode('', $this->aFlag), 'c-format') === false))
			{
				$this->aMsgstr = preg_replace(
					'/%([+\-#\'.0-9lLh]*[aAbcCdieEgGfmuosSpxX])/', 
					'@#@$1@#@', $this->aMsgstr, -1, $cnt);
				if ($cnt)
				{
					$cntVarStrips += $cnt;
					return  $cnt = 1 ? 
						sprintf(__("%d variable fue reemplazado en msgstr \"%s\"\n"), $cnt, $s) :
						sprintf(__("%d variables fueron reemplazado en msgstr \"%s\"\n"), $cnt, $s);
				}
			}
		}
		else	//if before PHP version 5.1.0
		{
			//because found at array position 0 and false are confusable, need to use !==
			if (strpos($s, '&') !== false)
			{	
				if (strpos($s, '&amp;') === false)
					$this->aMsgstr = preg_replace('/&(\w)/', '$1', $this->aMsgstr, -1);
				else
					$this->aMsgstr = preg_replace('/&amp;(\w)/', '$1', $this->aMsgstr, -1);
			}
			
			if (is_array($this->aFlag) && 
				!(strpos(implode('', $this->aFlag), 'c-format') === false))
			{
				$this->aMsgstr = preg_replace(
					'/%([+\-#\'.0-9lLh]*[aAbcCdieEgGfmuosSpxX])/', 
					'@#@$1@#@', $this->aMsgstr, -1);
			}

		}
		return false;
	}
	
}	//end class PoObj	

/* my_strpos() is my version of the standard strpos() function. It
is capable of taking arrays as its haystack and offset arguments.
If needle is an array, it searches for the first element of that array.
If haystack is an array, it searches within each array element. If the 
needle isn't found, returns FALSE, otherwise it returns a two element
array.  The first element is the position in the array where found and 
the second is the position within the string.  For example:
	$a = array("this is OK", "but *big* is better");
	$a = my_strpos("*big*", $a);  
	//now $a[0]=1, $a[1]=4 (found in array element 1 at string position 4)
If you want to start searching at different position in the array, set
strOffset and arrayOffset.*/
function my_strpos($haystack, $needle, $strOffset = 0, $arrayOffset = 0)
{
	if (!is_string($needle))
	{
		if (is_array($needle))
			$needle = $needle[0];
		
		if (is_int($needle) || is_float($needle))
			$needle = (string) $needle;
		
		if (!$is_string($needle))
			return false;
	}
	
	$aRet[0] = 0;
	
	if (!is_array($haystack))
	{
		if (is_string($haystack) && $arrayOffset == 0)
		{
			$aRet[1] = strpos($haystack, $needle, $strOffset);
			return ($aRet[1] === false ? false : $aRet);
		}
		else 
			return false;
	}
	
	for ($cnt = $arrayOffset; $cnt < count($haystack); $cnt++)
	{	
		$aRet[1] = strpos($haystack[$cnt], $needle, ($arrayOffset == $cnt) ? $strOffset : 0 );
		if (!($aRet[1] === false)) //if found
		{
			$aRet[0] = $cnt; 
			return $aRet;
		}
	}
	return false;
}

//The following function doesn't work, because when called like this:
//my_implode(a_PoObj->aMsgid);
//It copies the aMsgid array to $a as an empty string. Really annoying!
//I don't understand why it does this

//argument that isn't an array. If passed any other variable type, it
//returns that type.  This is useful in the ObjPo::match() function, 
//which does type-sensitive comparisons, so you don't want to loose
//the variable type when comparing strings to Nulls.
function myImplode($a)
{
	if (is_array($a))
		return implode('', $a);
	else
		return $a;
}
	
//get arguments passed by the user
function getArgs()
{
	global $argc, $argv, $sOrigPo, $sTransPo, $sNewPo, $bQuiet, $bShowPath,
		$bLog, $sLogFile, $bCommentIns, $sLangComment, $bOverwrite, $bVerbose, 
		$bBilingualIns, $sBilingualSeparator, $bMsgstrIns, $bNoStripVar,
		$bStatusBarIns, $sMenuSrch, $sStatusBarSrch, $bDebug, $sHelp, $bSearch
		$bRecursive, $sCharSet, $sInterfaceLang, $aGetText, $sProgramPath, $bDOS;
	
	$bHelp = false; //set to true to display help screen
	$bInfo = false; //set to true to diplay info (file readme-XX.txt)
	
	if ($argc < 2) 
		shutdown ($sHelp, 21);
	elseif ($argc == 2 && in_array(strtoupper($argv[1]), array('--HELP', '-HELP', 
			'-H', '-?', '/?')))
		$bHelp = true;
	elseif ($argc == 2 && strtoupper($argv[1]) == '-I' || strtoupper($argv[1]) == '--INFO')
		$bInfo = true;
	elseif ($argc < 3)
		shutdown(__("Error: Falta argumentos.\n\n") . $sHelp, 22);
		
	 
	for ($cntArgs = 1; $cntArgs < $argc; $cntArgs++)
	{
		if ($argv[$cntArgs][0] === '-')
		{
			$sArg = strtoupper($argv[$cntArgs]);
		
			if ($sArg == '-O' || $sArg == '--OVERWRITE')
				$bOverwrite = true;
			elseif ($sArg == '-V' || $sArg == '--VERBOSE')
				$bVerbose = true;
			elseif ($sArg == '-M' || $sArg == '--MSGSTR')
				$bMsgstrIns = true;
			elseif ($sArg == '-N' || $sArg == '--NO-STRIP')
				$bNoStripVar = true;
			elseif ($sArg == '-R' || $sArg == '--RECURSIVE')
				$bRecursive = True;
			//elseif ($sArg == '-P' || $sArg == '--SHOW-PATH')
			//	$bShowPath = true;
			elseif ($sArg == '-Q' || $sArg == '--QUIET')
				$bQuiet = True;
			elseif ($sArg == '-H' || $sArg == '--SEARCH')
				$bSearch = True;
			elseif ($sArg == '-D' || $sArg == '--DEBUG')
				$bDebug = true;
			elseif (!strncmp($sArg, '-F', 2) || !strncmp($sArg, '--INTERFACE', 11))
			{
				getSubArg($cntArgs, $sInterfaceLang, "--interface", "-f", __("IDIOMA"), "=", 25);
				$sInterfaceLang = strtolower($sInterfaceLang);
				
				if ($sInterfaceLang != DEF_SOURCE_LANG && 
						!file_exists($sProgramPath . '/locale/' . $sInterfaceLang))
				{
					output(sprintf(__("Aviso: Lengua de interfaz \"%s\" no es disponible.\n".
						"En su lugar usará lengua \"%s\".\n"), $sInterfaceLang, 
						DEF_INTERFACE_LANG), true);
						
					$sInterfaceLang = DEF_INTERFACE_LANG;
				}
				
				if ($sInterfaceLang != DEF_SOURCE_LANG)
					include_once($sProgramPath . '/locale/' . $sInterfaceLang);
					
				include($sProgramPath . '/help.php'); 
			}	
			elseif (!strncmp($sArg, '-S', 2) || !strncmp($sArg, '--STATUSBAR', 11))
			{
				$bStatusBarIns = true;		
				getSubArg($cntArgs, $sMenuSrch, "--statusbar", "-s", 
					__("FRASE-MENU"), "=", 23);
								
				if ($sMenuSrch === null)	//if search strings not specified, then set defaults
				{	
					$sMenuSrch = "MENU";
					$sStatusBarSrch = "STATUSBAR";
				}
				else
				{
					if ($cntArgs + 1 >= $argc)
						shutdown(__("Error: Hay que especificar la FRASE-BARRA-DE-ESTADO " .
							"de la opción --statusbar.\n\n") . $shelp, 24);
					else
						$sStatusBarSrch = $argv[++$cntArgs];
				}
			}
			elseif (!strncmp($sArg, '-C', 2) || !strncmp($sArg, '--COMMENT', 9))
			{
				$bCommentIns = true;
				getSubArg($cntArgs, $sLangComment, "--comment", "-c", __("IDIOMA"), "=", 25);
			}
			elseif (!strncmp($sArg, '-B', 2) || !strncmp($sArg, '--BILINGUAL', 11))
			{
				$bBilingualIns = true;
				getSubArg($cntArgs, $sBilingualSeparator, "--bilingual", "-b", 
					__("SEPARADOR"), "=", 24);
			}
			elseif (!strncmp($sArg, '-L', 2) || !strncmp($sArg, '--LOG', 5))
			{
				$bLog = true;
				getSubArg($cntArgs, $sLogFile, "--log", "-l", __("ARCHIVO"), "=", 24);
			}
			elseif (in_array($sArg, array('--HELP', '-HELP', '-H', '-?', '/?')))
				$bHelp = True;
			elseif ($sArg == '-I' || sArg == '--INFO')
				$bInfo = True;
		}
		elseif ($sOrigPo === null)
			$sOrigPo = $argv[$cntArgs];
		elseif ($sTransPo === null)
			$sTransPo = $argv[$cntArgs];
		elseif ($sNewPo === null)
			$sNewPo = $argv[$cntArgs];
		else
			shutdown(__("Error: Demasiado argumentos\n\n") . $sHelp, 26);
	}
	
	
	if ($bHelp)
		shutdown ($sHelp, 41);
	elseif ($bInfo)
	{
		//change current working directory to the same directory from which this program was run.
		chdir(pathinfo(realpath($argv[0]), PATHINFO_DIRNAME));
		
		//iconv has a bug, because it can't handle the first 3 bytes of a UTF-8 text file 
		shutdown(substr(file_get_contents(__("readme-es.txt")), 3), 42);
	}
	
	//check arguments:
	if ($sOrigPo === null)
		shutdown(__("Error: Hay que especificar ORIGINAL-PO y TRASLACIONES-PO.\n\n") . 
			$sHelp, 27);
	elseif ($sTransPo === null)
		shutdown(__("Error: Hay que especificar TRASLACIONES-PO.\n\n") . 
			$sHelp, 28); 
	elseif ($bBilingualIns && $bMsgstrIns)
		shutdown(__("Error: No se puede combinar opciones --msgstr y --bilingual.\n\n") . 
			$sHelp, 29);
			
	//check to see whether sOrigPo and sTransPo exist.
	if (myRealPath($sOrigPo) === false)
		shutdown(sprintf(__("Error: Archivo o directorio de ORIGINAL-PO \"%s\" no existe."), 
			$sOrigPo), 33); 
		
	if (myRealPath($sTransPo) === false)
		shutdown(sprintf(__("Error: Archivo o directorio de TRASLACIONES-PO \"%s\" no existe."), 
			$sTransPo), 34);
	
	//make sure that they have complete path names, because processDir() changes the current
	//working directory 
	$sOrigPo = myRealPath($sOrigPo);	
	$sTransPo = myRealPath($sTransPo);
	
	if ($sNewPo === null)
		$sNewPo = $sOrigPo;
	
	if (myRealPath($sNewPo) === false)
	{
		if (is_dir($sOrigPo)) //if a file, don't worry about it because won't be changing working dir
		{
			//will create the full path of directories if they don't exist
			if (!mkdir($sNewPo, 0777, true))	
				shutdown (sprintf(__("Error: No puede crear el directorio NUEVO-PO \"%s\"."),
					$sNewPo), 35);
			
			$sNewPo = myRealPath($sNewPo);
		}
	}
	else
		$sNewPo = myRealPath($sNewPo);		
			
			
	if (is_dir($sTransPo) != is_dir($sOrigPo))
	{
		if (is_dir($sOrigPo))
			shutdown(sprintf(__("Error: \"%s\" es un directorio, pero \"%s\" es un archivo.\n" .
				"Deben ser el mismo tipo.\n\n"), $sOrigPo, $sTransPo) .	$sHelp, 30);
		else
			shutdown(sprintf(__("Error: \"%s\" es un archivo, pero \"%s\" es un directorio.\n" .
				"Deben ser el mismo tipo.\n\n"), $sOrigPo, $sTransPo) . $sHelp, 31);
	}	
	
	//if none of the types of insertion are set, then set bMsgstrIns to true since it's the default
	if (!$bBilingualIns && !$bCommentIns && !$bMsgstrIns && !$bStatusBarIns)
		$bMsgstrIns = true;
	//make sure that some kind of insertion is taking place with the bStatusBarIns
	elseif ($bStatusBarIns && !$bBilingualIns && !$bCommentIns && !$bMsgstrIns)
		$bMsgstrIns = true;
		
	//if user didn't set $sLangComment, then set it to file name or directory name
	if ($bCommentIns && $sLangComment === null) 
	{
		//if directory, then get the last directory in path, 
		//Ex: get "es-ES" from "/home/user/strings/es-ES/"
		if (is_dir($sTransPo)) 
		{
			$sTemp = rtrim($sTransPo, '\\/');
			$pos = strrpos($sTemp, '\\') > strrpos($sTemp, '/') ? 
				strrpos($sTemp, '\\') : strrpos($sTemp, '/');
			$sLangComment = ltrim(substr($sTemp, $pos), '\\/');
		}
		else
			$sLangComment =  basename($sTransPo, '.po');
	}
	
		
	if ($bDebug)
	{
		print "\n\$argc: "; 		var_dump($argc);
		print "\$argv: " ; 			var_dump($argv);
		print "\$sOrigPo: " ; 		var_dump($sOrigPo);
		print "\$sTransPo: " ; 		var_dump($sTransPo);
		print "\$sNewPo: " ; 		var_dump($sNewPo);
		print "\$bLog: " ; 			var_dump($bLog);
		print "\$sLogFile: " ; 		var_dump($sLogFile);
		print "\$bMsgstrIns: "; 	var_dump($bMsgstrIns);
		print "\$bCommentIns: "; 	var_dump($bCommentIns);
		print "\$sLangComment: ";	var_dump($sLangComment);
		print "\$bOverwrite: " ; 	var_dump($bOverwrite);
		print "\$bQuiet: " ; 		var_dump($bQuiet);
		print "\$bVerbose: " ; 		var_dump($bVerbose); 
		print "\$bDebug: " ; 		var_dump($bDebug); 
		print "\$bBilingualIns: " ; var_dump($bBilingualIns);
		print "\$sBilingualSeparator: "; var_dump($sBilingualSeparator); 
		print "\$bStatusBarIns: " ; var_dump($bStatusBarIns);
		print "\$sMenuSrch: " ; 	var_dump($sMenuSrch); 
		print "\$sStatusBarSrch: " ; var_dump($sStatusBarSrch); 
		print "\$bRecursive: " ; 	var_dump($bRecursive); 
		print "\$sInterfaceLang: ";	var_dump($sInterfaceLang); 
		print '$bDOS: ';			var_dump($bDOS);				
		print '$sCharSet: ';		var_dump($sCharSet);
		print '$sProgramPath: ';	var_dump($sProgramPath);
			
		//if want to see $aGetText, also uncomment exit() to avoid messy output. 
		//print '$aGetText: ';		var_dump($aGetText);
		//exit(0);  
	}
	
	return;
}

/*function getSubArg() is used when you need to check if an argument passed by the
user has a sub-argument as well. For instance, in the --bilingual option, you can 
check if the "= SEPARATOR" sub-argument was passed.  
Parameters: 
&$cntArgs is a reference to the argument count variable
&$subArgVar the variable which will contain the sub-argument
$sLongArg is the long name of the argument. Ex: "--bilingual"
$sShortArg is the short name of the argument. Ex: "-b"
$sSubArgName is the name of the subargument. Ex: "SEPARADOR"
$sSubArgFlag is the string which identifies a subargument. Ex: "="
$iErrorNo is the error number for the program to return if the subArgument 
wasn't given correctly. Example function call: 
getSubArg($CntArgs, $sBilingualSeparator, "--bilingual", "-b", "SEPARADOR", "=", 24); */				
function getSubArg(&$cntArgs, &$subArgVar, $sLongArg, $sShortArg, $sSubArgName, 
			$sSubArgFlag, $iErrorNo)
{
	global $argv, $argc, $sHelp;
	$sArg = $argv[$cntArgs];
	
	if (!strncasecmp($sArg, $sShortArg, 2))
		$sArg = substr($argv[$cntArgs], 2); 
	else
		$sArg = substr($argv[$cntArgs], strlen($sLongArg));
	
	//if substr goes past the end of the string, then returns false 				
	if (is_string($sArg) && strlen($sArg) > 0) //if the string continues 
	{
		if ($sArg[0] != $sSubArgFlag)
			shutdown(sprintf(__(
				"Error: Necesita usar \"%s\" para especificar el %s de la opción %s\n\n"), 
				$sSubArgFlag, $sSubArgName, $sLongArg) . $sHelp, $iErrorNo);							
		elseif (strlen($sArg) == 1)
			$subArgVar = $argv[++$cntArgs];
		else
			$subArgVar = trim(substr($sArg, 1), '"');
	}
	//If end of the arguments or if didn't specify a subargument for the option.
	//If the last argument then probably an error but allow user to put 
	//optiones after the filenames like: instrans.php qu-BO.po es-ES.po -b
	elseif ($argc <= $cntArgs + 1 || $argv[$cntArgs + 1][0] != $sSubArgFlag)
		return;
	//if did specify a subargument, then get it
	elseif (strlen($argv[++$cntArgs]) > 1)
		$subArgVar = trim(substr($argv[$cntArgs], 1), '"');
	elseif ($argc <= $cntArgs + 1)
		return;
	else
		$subArgVar = $argv[++$cntArgs];
		
	return;
}

	
//Function findAutoComMatch() searches through the array aTransPo for a PO
//Object with an Automatic Comment of $sSearchAutoCom. This is useful when 
//looking to match Menus with Status Bar PO objects. Returns -1 if not found,
//or the position in the aTransPo where it was found. 
function findAutoComMatch($sSearchAutoCom)
{
	global $aTransPo; 
	
	$lenTransPo = count($aTransPo);
	$cntTransPo = 0;
	
	//Loop to search through the aTransPo array
	for ($cntTransPo = 0; $cntTransPo < $lenTransPo; $cntTransPo++)
	{
		//3rd parameter (true) so that it will do strict matching, so NULL won't equal ''.
		if (is_array($aTransPo[$cntTransPo]->aAutoCom) &&
				in_array($sSearchAutoCom, $aTransPo[$cntTransPo]->aAutoCom, true))
			return $cntTransPo;
	}
	
	return -1;
}  

//Function findPoMatch() searches through the array aTransPo for a PO object
//that matches oPo and returns the position in the array where it was found
//Returns -1 if not found.
//iSearchFirst is the first position in the array aTransPo to search.  If 
//match not found at position iSearchFirst, then will search sequentially 
//through the entire array for a match. 

//Note:
//In most cases, rOrigPoFile and rTransPoFile will have the exact same order
//of PO frases, so match will be found at iSearchFirst. If the two files
//don"t have the same order, then this program will run very slow, because
//have to search sequentially through the entire file.Maybe I should sort 
//aTransPo for faster searching in a later revision of this code.
function findPoMatch(PoObj $oPo, $iSearchFirst = 0)
{
	global $aTransPo; 
	
	$lenTransPo = count($aTransPo);

	//check that $iSearchFirst is within bounds
	if (!is_int($iSearchFirst) || $iSearchFirst < 0 || $lenTransPo <= $iSearchFirst)
		$iSearchFirst = 0;	
	
	if ($aTransPo[$iSearchFirst]->match($oPo) == 4)
		return $iSearchFirst;
	
	$lastMatchPos = null; 
	$lastMatchVal = 0;

	//Loop to search through the aTransPo array for the best match.
	//Match values range from zero (no match) to 4 (perfect match) 
	for ($cntObj = 0; $cntObj < $lenTransPo; $cntObj++)
	{
		$curMatchVal = $aTransPo[$cntObj]->match($oPo);

		//only match the msgid in --search mode but try to match the msgid, 
		//automatic comments and reference in normal mode
		if ($curMatchVal == 4 || ($bSearch && $curMatchVal > 0))
			return $cntObj;
		elseif ($lastMatchVal < $curMatchVal)
		{
			$lastMatchVal = $curMatchVal;
			$lastMatchPos = $cntObj;
		}
	}
	
	if ($lastMatchVal > 0)	//if some match was found
		return $lastMatchPos;
	else
		return -1;
}  

//print function which checks whether in verbose and log-to-file mode
//$sMsg is the string to print to screen or write to the log file
//$Set bAlways to true if you want to make sure that $sMsg gets outputted
function output($sMsg, $bAlways = false)
{
	global $bLog, $bVerbose, $sLogFile, $rLogFile, $sCharSet;
	
	if ($bLog)
	{
		if(fputs($rLogFile, $sMsg, 3000) === false)
			shutdown(sprintf(__("Error escribiendo al archivo log \"%s\"."), 
				$sLogFile), 20);
	}
	elseif ($bVerbose || $bAlways)
		print $sCharSet == 'UTF-8' ? $sMsg : iconv('UTF-8', $sCharSet, $sMsg);
			
	return;
}
		

//Function to shutdown the program and delete temporary files if necessary
function shutdown($sMessage = '', $iRetVal = 0)
{
	global $bLog, $rLogFile, $rTempFile, $sTempFile, $sCharSet, 
		$bDebug, $bDOS, $sProgramPath, $rTempDir, $sTempDir;
	
	if ($bLog && is_resource($rLogFile))
		fputs($rLogFile, "\n" . $sMessage . "\n");
	else	
		print "\n" . iconv("UTF-8", $sCharSet, $sMessage) . "\n";
	
	//get rid of temporary file if exists
	if (isset($sTempFile) && file_exists($sTempFile) && !$bDebug) 
	{
		if (is_resource($rTempFile))
			fclose($rTempFile);
			
		//Can"t figure out the setting in php.ini to allow the unlink command to work.
		@unlink($sTempFile);
	}
		
	//get rid of temporary directory if exists
	if (isset($sTempDir) && file_exists($sTempDir) && !$bDebug) 
	{
		if (is_resource($rTempDir))
			closedir($rTempDir);
			
		chdir($sProgramPath); //in case instrans is inside the temporary directory
	
		if ($bDOS)
			@system('rmdir /s /q ' . $sTempDir);
		else 	//if Linux/UNIX/OS X
			@system('rm -r -d ' . $sTempDir); 			
	}

	exit($iRetVal);
}	

$rTransPoFile = fopen($sTransPoFile, 'rt');
	
	if ($rTransPoFile === false)
		shutdown(sprintf(__("Error: No puede abrir el archivo \"%s\"."), $sTransPoFile), 5);
	
	//if not in Search Mode (--search), then clear the array of PO objects read from sTransPo
	if (!$bSearch)
		$aTransPo = null; 

	$aTransPo[] = new PoObj();	//create first object in the array.
	$bCreateNewObj = false;

	//loop to pull one line at a time out of file rTransPoFile and then put
	//the lines into array aTransPo.
	while(true)
	{
		$sLine = fgets($rTransPoFile);
	
		if ($sLine === false)
		{
			if (feof($rTransPoFile))
				break;
			else
				shutdown(sprintf(__("Error leyendo archivo \"%s\"."), $sTransPoFile), 7);
		}
	
		$cntTransPoFileLines++;
		
		if (trim($sLine) === '')
		{
			$bCreateNewObj = true;
			continue;
		}
		
		if ($bCreateNewObj === true)
		{
			//checks whether the PO object has both a msgid and msgstr defined
			if (!is_array($aTransPo[$cntTransPoObjs]->aMsgstr) && 
				is_array($aTransPo[$cntTransPoObjs]->aMsgid) != 
				is_array($aTransPo[$cntTransPoObjs]->aMsgstr))
			{
				$cntTransPoSyntaxErr++;
				$sOut = sprintf(__(
					"Error de sintaxis en línea %d del archivo \"%s\"\n" .
					"No hay un msgstr definido para el msgid \"%s\"\n\n"), 
					$cntTransPoFileLines - 1, $sTransPoFile, 
					implode('', $aTransPo[$cntTransPoObjs]->aMsgid));
				output($sOut);
			}
	
			$bCreateNewObj = false;
			$aTransPo[] = new PoObj(); 
			$cntTransPoObjs++;
		}
	
		if ($aTransPo[$cntTransPoObjs]->addLine($sLine) <= -2)
		{
			$cntTransPoSyntaxErr++;
			$sOut = sprintf(__("Error de sintaxis en línea %d del archivo \"%s\"\n" . 
				"%s\nLínea: %s\n\n"), $cntTransPoFileLines, $sTransPoFile, $sErr, $sLine);
			output($sOut);
		}
	}
	
	if ($cntTransPoObjs == 0 && $aTransPo[0]->aMsgid === null)
		shutdown(sprintf(__("Error: Archivo \"%s\" no contiene ningunas frases PO."), 
			$sTransPoFile), 8);



//Function to process a single PO file
//$sNewPoFile is the name of the new PO file to be written--if a dirctory, then this 
//is in a temporary directory
//$sFinalPoFile is the name that the new PO file will have when program finishes and
//renames the temporary directory to $sNewPo 
function processPoFile($sOrigPoFile, $sTransPoFile, $sNewPoFile, $sFinalPoFile)
{
	global $bMsgstrIns, $bCommentIns, $bOverwrite, $bVerbose, $bQuiet, $bRecursive, 
	$bShowPath, $bNoStripVar, $bBilingualIns, $sBilingualSeparator, $bStatusBarIns,
	$sMenuSrch, $sStatusBarSrch, $sLangComment, $sErr, $bDir, $aTransPo,
	$totAmpersandStrips, $totVarStrips, $totOrigPoFileLines, $totTransPoFileLines, 
	$totNewPoFileLines, $totOrigPoObjs, $totTransPoObjs, $totNewPoObjs, 
	$totOrigPoSyntaxErr, $totTransPoSyntaxErr, $totNewPoSyntaxErr, $totFraseInserts,
	$cntAmpersandStrips, $cntVarStrips, $sTempFile;

	$funcTime = microtime(true); //start time so can calculate time to process file
	
	//Set counters to 0. These will be added to the global counters when done processing the file
	$cntAmpersandStrips = 0; 
	$cntVarStrips =  0;
	$cntOrigPoFileLines = 0;
	$cntTransPoFileLines = 0;
	$cntNewPoFileLines = 0;
	$cntOrigPoObjs = 0;
	$cntTransPoObjs = 0;
	$cntNewPoObjs = 0;
	$cntOrigPoSyntaxErr = 0;
	$cntTransPoSyntaxErr = 0; 
	$cntNewPoSyntaxErr = 0;
	$cntFraseInserts = 0;

	$rTransPoFile = fopen($sTransPoFile, 'rt');
	
	if ($rTransPoFile === false)
		shutdown(sprintf(__("Error: No puede abrir el archivo \"%s\"."), $sTransPoFile), 5);
	
	//if not in Search Mode (--search), then clear the array of PO objects read from sTransPo
	if (!$bSearch)
		$aTransPo = null; 

	$aTransPo[] = new PoObj();	//create first object in the array.
	$bCreateNewObj = false;

	//loop to pull one line at a time out of file rTransPoFile and then put
	//the lines into array aTransPo.
	while(true)
	{
		$sLine = fgets($rTransPoFile);
	
		if ($sLine === false)
		{
			if (feof($rTransPoFile))
				break;
			else
				shutdown(sprintf(__("Error leyendo archivo \"%s\"."), $sTransPoFile), 7);
		}
	
		$cntTransPoFileLines++;
		
		if (trim($sLine) === '')
		{
			$bCreateNewObj = true;
			continue;
		}
		
		if ($bCreateNewObj === true)
		{
			//checks whether the PO object has both a msgid and msgstr defined
			if (!is_array($aTransPo[$cntTransPoObjs]->aMsgstr) && 
				is_array($aTransPo[$cntTransPoObjs]->aMsgid) != 
				is_array($aTransPo[$cntTransPoObjs]->aMsgstr))
			{
				$cntTransPoSyntaxErr++;
				$sOut = sprintf(__(
					"Error de sintaxis en línea %d del archivo \"%s\"\n" .
					"No hay un msgstr definido para el msgid \"%s\"\n\n"), 
					$cntTransPoFileLines - 1, $sTransPoFile, 
					implode('', $aTransPo[$cntTransPoObjs]->aMsgid));
				output($sOut);
			}
	
			$bCreateNewObj = false;
			$aTransPo[] = new PoObj(); 
			$cntTransPoObjs++;
		}
	
		if ($aTransPo[$cntTransPoObjs]->addLine($sLine) <= -2)
		{
			$cntTransPoSyntaxErr++;
			$sOut = sprintf(__("Error de sintaxis en línea %d del archivo \"%s\"\n" . 
				"%s\nLínea: %s\n\n"), $cntTransPoFileLines, $sTransPoFile, $sErr, $sLine);
			output($sOut);
		}
	}
	
	if ($cntTransPoObjs == 0 && $aTransPo[0]->aMsgid === null)
		shutdown(sprintf(__("Error: Archivo \"%s\" no contiene ningunas frases PO."), 
			$sTransPoFile), 8);
		
	//Open the original PO file for reading
	$rOrigPoFile = fopen($sOrigPoFile, 'rt');
	
	if ($rOrigPoFile === false)
		shutdown(sprintf(__("Error: No puede abrir archivo \"%s\" para leerlo."),
			$sOrigPoFile), 9);
	
	//Open a temporary file for writing the new PO file	
	$sTempFile = tempnam(getcwd(), 'instrans_temp_');
	
	if($sTempFile === false)
		shutdown(__("Error: No puede crear un archivo temporario."), 10);
	
	$rTempFile = fopen($sTempFile,'wt');
	
	if ($rTempFile === false)	
		shutdown(__("Error: No puede abrir un archivo temporario para escribirlo."), 11);
		
	$curPo = new PoObj(); //holds current PO object pulled from the original PO file
	 
	//Loop to extract each PO object from the original PO file and
	//put it in curPo. Then searches for a matching PO object 
	//in array aTransPo (which contains the PO objects found in rTransPoFile).
	//Then copies the translation from aTransPO and insert it into curPo.
	do
	{
		$sLine = fgets($rOrigPoFile);
		
		if ($sLine === false && !feof($rOrigPoFile))
			shutdown(sprintf(__("Error leyendo archivo \"%s\"."), $sOrigPoFile), 12);
		else
			$cntOrigPoFileLines++;
	
		$retVal = $curPo->addLine($sLine);
	
		if ($retVal <= -2)
		{
			$cntOrigPoSyntaxErr++;
			
			if ($sOrigPoFile == $sNewPoFile)
				$sOut = sprintf(__("Error de sintaxis en línea %d del archivo \"%s\"\n" . 
					"%s\nLínea: %s\n\n"), $cntNewPoFileLines + $curPo->cntLines(), 
					$sOrigPoFile, $sErr, $sLine);
			else 
				$sOut = sprintf(__("Error de sintaxis en línea %d del archivo \"%s\"\n" .
					"%s\nLínea: %s\nChequee línea %d del archivo \"%s\".\n\n"), 
					$cntOrigPoFileLines, $sOrigPoFile, $sErr, $sLine, 
					$cntNewPoFileLines + $curPo->cntLines(), $sFinalPoFile);
			
			output($sOut);
		}
					
		if ($retVal === 0 || feof($rOrigPoFile)) //if the end of the PO Object
		{
			if ($curPo->aMsgid === null)
			{
				$linesIns = $curPo->cntLines();
				if ($linesIns > 0)
				{
					if (fputs($rTempFile, $curPo->getStr(), $linesIns * 256 ) === false)
						shutdown(sprintf(__("Error escribiendo al archivo temporario \"%s\"."),
							$sTempFile), 15);
						
					$cntNewPoFileLines += $linesIns;
				}
				
				if (feof($rOrigPoFile))
					break;
				else
					continue;
			}
			
			//checks whether the PO object has both a msgid and msgstr defined
			if (is_array($curPo->aMsgid) != is_array($curPo->aMsgid) && !is_array($curPo->aMsgid))
			{
				$cntOrigPoSyntaxErr++;
						
				if ($sOrigPoFile === $sNewPoFile)
					$sOut .= sprintf(__("Error de sintaxis en línea %d del archivo \"%s\"\n" .
						"No hay un msgstr definido para el msgid \"%s\"\n\n"), 
						$cntNewPoFileLines + $curPo->cntLines(), $sOrigPoFile, 
						implode('', $curPo->aMsgid));
				else 
					$sOut = sprintf(__("Error de sintaxis en línea %d de archivo \"%s\"\n" . 
						"No hay un msgstr definido para el msgid \"%s\"\n" . 
						"Chequee línea %d del archivo \"%d\".\n\n"), 
						$cntOrigPoFileLines - 1, $sOrigPoFile, implode('', $curPo->aMsgid), 
						$cntNewPoFileLines + $curPo->cntLines(), $sFinalPoFile);
				
				output($sOut);	
			}
			
			$cntOrigPoObjs++;
			
			if ($bStatusBarIns)
			{
				if (is_array($curPo->aAutoCom))
				{
					$retVal = my_strpos($curPo->aAutoCom, $sStatusBarSrch);
				
					//if Automatic Comment contains the Status Bar identifier
					if (!($retVal === false)) 
					{
						$posPo = findAutoComMatch(str_replace($sStatusBarSrch, 
							$sMenuSrch, $curPo->aAutoCom[$retVal[0]]));
					}
					else
						$posPo = -1; // signal that there was no match found
				}
				else $posPo = -1;
			}
			else 
				$posPo = findPoMatch($curPo, $cntOrigPoObjs);
					
	
			if ($posPo >= 0) //if match found
			{
				if ($bCommentIns)	//if inserting translation as a comment
				{
					$aNew = null;
					
					if (is_array($aTransPo[$posPo]->aMsgstr))
					{
						foreach($aTransPo[$posPo]->aMsgstr as $st)
							$aNew[] = '[' . $sLangComment . 
								($bStatusBarIns ? '] MENU: "' : '] "') . $st . '"';
					}
	
					if ($bOverwrite)
					{
						if (is_array($curPo->aTransCom))
						{
							foreach($curPo->aTransCom as $st)
							{
								//only keep comments that don't match the form:
								// [FILENAME] "TRANSLATION" or 
								// [FILENAME] MENU: "TRANSLATION if bStatusBarIns 
								if (!ereg($bStatusBarIns ? "^\[.+\] MENU: \".*\"$" : 
										"^\[.+\] \".*\"$", $st)) 
									$aNew[] = $st;
							}
						}
					}
					else	//if not overwriting comments
					{
						if (is_array($curPo->aTransCom))
							foreach($curPo->aTransCom as $st)
								$aNew[] = $st;
					}
					
					$curPo->aTransCom = $aNew;
				}
				
				if($bBilingualIns) 
				{
					if (is_array($aTransPo[$posPo]->aMsgstr) && $aTransPo[$posPo]->strMsgstr() != '')
					{
						$cntArray = count($curPo->aMsgstr);
						
						//if curPo doesn't have a msgstr
						if ($cntArray == 0 || ($cntArray == 1 && $curPo->aMsgstr == '')) 
						{
							//clear the msgstr so start autoincrementing from zero
							$curPo->aMsgstr = null; 
							
							foreach($aTransPo[$posPo]->aMsgstr as $st)
								$curPo->aMsgstr[] = $st;
						}
						else // if curPo does have an existing msgstr
						{
							$s1 = $curPo->strMsgstr();
							
							if (!$bNoStripVar)
							{	//strip ampersands and variables from msgstr
								$sWarning = $aTransPo[$posPo]->stripDangerous();
							
								if (!($sWarning === false))
								{
									$sOut = sprintf(__("Archivo \"%s\" línea %d:\n"), 
										$sFinalPoFile, $cntNewPoFileLines + $curPo->cntLines());
									output($sOut . $sWarning);
								}
							}
							
							//Set the separator between the two msgstr according to 
							//whether the existing msgstr is spaces, has a new line 
							//character, or is a normal msgstr
							if (trim($s1) == '') 				//only space or empty
								$sSeparator = '';	
							elseif (strpos($s1, '\n') === false) //no new line char.
								$sSeparator = $sBilingualSeparator;
							else  				//if contains new line character
								$sSeparator = '\n';
						
							//append to the same line as the existing msgstr
							if ($sSeparator != '\n' && strlen($s1) < 40)
							{
								$curPo->aMsgstr = null; //clear the array
								$curPo->aMsgstr[] = $s1 . $sSeparator . 
									$aTransPo[$posPo]->strMsgstr();
							}
							else //if appending extra lines
							{
								foreach($aTransPo[$posPo]->aMsgstr as $st)
								{
									$curPo->aMsgstr[] = $sSeparator . $st;
									//set to empty string so only insert separator for the first iteration
									$sSeparator = ''; 
								}
							}
						}
					}
				}
				elseif($bMsgstrIns) 	//if inserting translation as the msgstr
				{
					if ($bOverwrite || $curPo->aMsgstr === null || 
						($curPo->aMsgstr[0] === '' && count($curPo->aMsgstr) == 1))
					{	
						$curPo->aMsgstr = null;	
						
						if (is_array($aTransPo[$posPo]->aMsgstr))
						{
							if ($bStatusBarIns && !$bNoStripVar)
							{
								$sWarning = $aTransPo[$posPo]->stripDangerous();
								if ($sWarning !== false)
									output(sprintf(__(
										"Archivo \"%s\" línea %d:\n"), $sFinalPoFile, 
										$cntNewPoFileLines + $curPo->cntLines()) . $sWarning); 
							}
								
							foreach($aTransPo[$posPo]->aMsgstr as $st)
								$curPo->aMsgstr[] = $st;
						}
					}
				}
			}
			//+1 for extra line of whitespace after each PO object	
			$linesIns = $curPo->cntLines() + 1;
			
			if (fputs($rTempFile, $curPo->getStr(), $linesIns * 256 ) === false)
				shutdown(sprintf(__("Error escribiendo al archivo temporario \"%s\"."), 
					$sTempFile), 15);
			
			//+1 for extra line of whitespace after each PO object	
			$cntNewPoFileLines += $linesIns;	 
			$curPo->clear();	
			$cntNewPoObjs++;		
		}
	} while (!feof($rOrigPoFile));
				
	fclose($rOrigPoFile);
	fclose($rTransPoFile);
	fclose($rTempFile);
	
	//if the sNewPoFile exists, then delete it.
	if (file_exists($sNewPoFile))
	{
		if (!unlink($sNewPoFile))	
			shutdown(sprintf(__("Error: No puede borrar el archivo \"%s\" para reemplazarlo."),
				$sFinalPoFile), 16);
	}
	
	if (!rename($sTempFile, $sNewPoFile))
		shutdown(__("Error: No puede dar un nuevo nombre a un archivo temporario."), 17);
	
	if (!$bQuiet && $bDir)
	{	
		if ($bVerbose)
		{
			$sOut = sprintf(__("\nResumen de \"%s\":\n" .
				"%d líneas, %d objetos PO y %d errores de sintaxis leido del archivo \"%s\"\n" . 
				"%d líneas, %d objetos PO y %d errores de sintaxis leido del archivo \"%s\"\n" .
				"%d líneas y %d objetos PO escrito en el archivo \"%s\"\n"), $sFinalPoFile, 
				$cntOrigPoFileLines, $cntOrigPoObjs, $cntOrigPoSyntaxErr, $sOrigPoFile,
				$cntTransPoFileLines, $cntTransPoObjs, $cntTransPoSyntaxErr, $sTransPoFile,
				$cntNewPoFileLines, $cntNewPoObjs, $sFinalPoFile);
			
			if (($bStatusBarIns || $bBilingualIns) && substr(phpversion(), 0, 3) >= 5.1)
				$sOut .= sprintf(__("%d signos \"&\" y %d variables quitado.\n"), 
					$cntAmpersandStrips, $cntVarStrips);
		
			$sOut .= sprintf(__("Tiempo de procesamiento: %f segundos.\n"), 
				microtime(true) - $funcTime);
			output($sOut);
		}
		else
		{
			$sOut = sprintf(__("%d objetos PO escrito en el archivo \"%s\"\n"), 
				$cntNewPoObjs, $sFinalPoFile);
			output($sOut, true);
		}
	}
	
	//Add to the global counters:
	$totAmpersandStrips += $cntAmpersandStrips; 
	$totVarStrips += $cntVarStrips;
	$totOrigPoFileLines += $cntOrigPoFileLines;
	$totTransPoFileLines += $cntTransPoFileLines;
	$totNewPoFileLines += $cntNewPoFileLines;
	$totOrigPoObjs += $cntOrigPoObjs;
	$totTransPoObjs += $cntTransPoObjs;
	$totNewPoObjs += $cntNewPoObjs;
	$totOrigPoSyntaxErr += $cntOrigPoSyntaxErr;
	$totTransPoSyntaxErr += $cntTransPoSyntaxErr; 
	$totNewPoSyntaxErr += $cntNewPoSyntaxErr;
	$totFraseInserts += $cntFraseInserts; //not implemented yet
	
	return 0;
}

//function that can be called recursively to process a directory.  It copies files
//that aren't PO files to the new directory $sNewPoDir and calls the function 
//processPoFile() when it encounters a PO file.  If it encounters another directory
//and the --recursive option is set, then it calls itself to process that directory.
function processDir($sOrigPoDir, $sTransPoDir, $sTempPoDir, $sNewPoDir)
{
	global $bRecursive, $bDOS;
	
	$cSlash = $bDOS ? '\\' : '/';
	$sOldCWD = getcwd();
	$rOrigPoDir = opendir($sOrigPoDir);
	chdir($sOrigPoDir); //readdir() returns only filenames, so need to change working dir
	
	if (!$rOrigPoDir)
		shutdown(sprintf(__("Error: No puede abrir el directorio \"%s\"."), 
			$sOrigPoDir), 20);
		
	while (true)
	{
		$sNextInDir = readdir($rOrigPoDir);
		 
		if ($sNextInDir === false)
			break;
		elseif ($sNextInDir == '.' || $sNextInDir == '..')
			continue;
		elseif (is_dir($sNextInDir))
		{
			if ($bRecursive)
			{	
				if (!mkdir($sTempPoDir . $cSlash . $sNextInDir))
					shutdown(sprintf(__("Error: No puede crear directorio \"%s\"."),
						$sNewPoDir . $cSlash . $sNextInDir), 22);
				
				processDir($sOrigPoDir . $cSlash . $sNextInDir, $sTransPoDir . $cSlash . $sNextInDir, 
					$sTempPoDir . $cSlash . $sNextInDir, $sNewPoDir . $cSlash . $sNextInDir);		
			}
		}	
		elseif (isPoFile($sNextInDir))
		{
			processPoFile($sOrigPoDir . $cSlash . $sNextInDir, $sTransPoDir . $cSlash . $sNextInDir, 
				$sTempPoDir . $cSlash . $sNextInDir, $sNewPoDir . $cSlash . $sNextInDir);
		}	
		else //if not a PO file, then just copy it over to the sNewPoDir
		{	
			if (!copy($sOrigPoDir . $cSlash . $sNextInDir, $sTempPoDir . $cSlash . $sNextInDir)) 
				shutdown(sprintf(__("Error: No puede copiar archivo \"%s\"."), $sNextInDir), 21);
		}	
	}
	
	closedir($rOrigPoDir);
	chdir($sOldCWD);
	return 0;
}

function isPoFile($sFile)
{
	$sExt = strtoupper(pathinfo($sFile, PATHINFO_EXTENSION));
	
	if (($sExt == 'PO' || $sExt == 'POT' || $sExt == 'POX') && is_readable($sFile))
	{
		//later write code to examine first 20 lines and check if really a PO file
		return true;
	}
	else
		return false;
}
	
//because realpath() doesn't work on directory names, created this function which
//can handle both file and directory names
function myRealPath($sFileOrDir)
{
	if (!file_exists($sFileOrDir))
		return false;
	elseif (is_file($sFileOrDir))
		return realpath($sFileOrDir);
	else //only directories left now
	{ 
		$sCWD = getcwd();
		chdir($sFileOrDir);
		$sPath = getcwd();
		chdir($sCWD); 
		return $sPath;
	}
}

?>
